> 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。
> 
> 示例 1:
> 
> 输入: "aba" 
> 输出: True 
> 示例 2:
> 
> 输入: "abca" 
> 输出: True 
> 解释: 你可以删除c字符。

贪心算法
考虑最朴素的方法：首先判断原串是否是回文串，如果是，就返回 true；如果不是，则枚举每一个位置作为被删除的位置，再判断剩下的字符串是否是回文串。这种做法的渐进时间复杂度是 O(n^2)，会超出时间限制。

首先考虑如果不允许删除字符，如何判断一个字符串是否是回文串。常见的做法是使用双指针。定义左右指针，初始时分别指向字符串的第一个字符和最后一个字符，每次判断左右指针指向的字符是否相同，如果不相同，则不是回文串；如果相同，则将左右指针都往中间移动一位，直到左右指针相遇，则字符串是回文串。

在允许最多删除一个字符的情况下，同样可以使用双指针，通过贪心算法实现。初始化两个指针 low 和 high 分别指向字符串的第一个字符和最后一个字符。每次判断两个指针指向的字符是否相同，如果相同，则更新指针，令 low = low + 1 和 high = high - 1，然后判断更新后的指针范围内的子串是否是回文字符串。如果两个指针指向的字符不同，则两个字符中必须有一个被删除，此时我们就分成两种情况：即删除左指针对应的字符，留下子串s[low + 1], ..., s[high]，或者删除右指针对应的字符，留下子串 s[low], s[low + 1], ..., s[high - 1]。当这两个子串中至少有一个是回文串时，就说明原始字符串删除一个字符之后就以成为回文串。

```javascript
var validPalindrome = function(s) {
    let palindrome = function(s,i,j){
        for(;i <= j; i++,j--){
            if(s[i] !== s[j]) return false;
        }
        return true;
    };

    let i = 0,j = s.length - 1;
    for(;i <= j; i++,j--){
        if(s[i] !== s[j]) return palindrome(s,i+1,j) || palindrome(s,i,j-1);
    }
    return true;
};
```
复杂度分析
时间复杂度：O(n)，其中 n 是字符串的长度。判断整个字符串是否是回文字符串的时间复杂度是 O(n)，遇到不同字符时，判断两个子串是否是回文字符串的时间复杂度也都是 O(n)。
空间复杂度：O(1)。只需要维护有限的常量空间。
