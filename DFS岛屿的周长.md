> 给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。
> 
> 网格中的格子水平和垂直方向相连（对角线方向不相连）。
> 整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。
> 
> 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。
> 格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100。
> 计算这个岛屿的周长。

> 示例 :
> 
> 输入: 
> [[0,1,0,0],  
> [1,1,1,0],  
> [0,1,0,0],  
> [1,1,0,0]]
> 
> 输出: 16
> 
> 解释: 它的周长是下面图片中的 16 个黄色的边：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201112025919357.png#pic_center)
方法一：迭代
对于一个陆地格子的每条边，它被算作岛屿的周长当且仅当这条边为网格的边界或者相邻的另一个格子为水域。 因此，我们可以遍历每个陆地格子，看其四个方向是否为边界或者水域，如果是，周长加1。

```javascript
var islandPerimeter = function(grid) {
    let count = 0;
    for(let i = 0;i < grid.length;i++){
        for(let j = 0;j < grid[0].length;j++){
            if(grid[i][j] == 1){
                if(j == 0 || grid[i][j-1] == 0) count++;//left
                if(i == 0 || grid[i-1][j] == 0) count++;//top
                if(j == grid[0].length - 1 || grid[i][j+1] == 0) count++;//right
                if(i == grid.length - 1|| grid[i+1][j] == 0) count++;//bottom
            }
        }
    }
    return count;
};
```
复杂度分析
时间复杂度：O(nm)，其中 n为网格的高度，m为网格的宽度。我们需要遍历每个格子，每个格子要看其周围 4个格子是否为岛屿，因此总时间复杂度为 O(4nm)=O(nm)。
空间复杂度：O(1)。只需要常数空间存放若干变量。


方法二：深度优先搜索DFS
此时遍历的方式**可扩展至统计多个岛屿各自的周长**。需要注意的是为了防止陆地格子在深度优先搜索中被重复遍历导致死循环，我们需要将遍历过的陆地格子标记为已经遍历过，下面的代码中我们设定值为 2 的格子为已经遍历过的陆地格子。

```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var islandPerimeter = function(grid) {
    let dfs = function(grid,r,c){
        if(r<0 || r>=grid.length || c <0 || c>=grid[0].length) return 1;//边界
        if(grid[r][c] == 0) return 1;//水域
        if(grid[r][c] != 1) return 0;
        grid[r][c] = 2;//遍历过的标志，防止重复遍历
        return dfs(grid,r,c+1) 
            +  dfs(grid,r,c-1)
            +  dfs(grid,r+1,c)
            +  dfs(grid,r-1,c);
    }

    let count = 0;
    for(let i = 0;i < grid.length;i++){
        for(let j = 0; j < grid[0].length; j++){
            if(grid[i][j] == 1){
                count += dfs(grid,i,j);
            }
        }
    }
    return count;
};
```
复杂度分析
时间复杂度：O(nm)，其中 n为网格的高度，m为网格的宽度。每个格子至多会被遍历一次，因此总时间复杂度为 O(nm)。
空间复杂度：O(nm)。深度优先搜索复杂度取决于递归的栈空间，而栈空间最坏情况下会达到 O(nm)。

**如何在网格上做 DFS**
网格问题是这样一类搜索问题：有 m×n 个小方格，组成一个网格，每个小方格与其上下左右四个方格认为是相邻的，要在这样的网格上进行某种搜索。

下面我们一步步地构造出方格类 DFS 的代码。

 - 首先，每个方格与其上下左右的四个方格相邻，则 DFS 每次要分出四个岔。
 - 但是，对于网格边缘的方格，上下左右并不都有邻居。一种做法是在递归调用之前判断方格的位置，例如位于左边缘，则不访问其左邻居。但这样一个一个判断写起来比较麻烦，我们可以用“先污染后治理”的方法，先做递归调用，再在每个 DFS 函数的开头判断坐标是否合法，不合法的直接返回。
 - 但是这样还有一个问题：DFS 可能会不停地“兜圈子”，永远停不下来，那么我们需要标记遍历过的方格，保证方格不进行重复遍历。标记遍历过的方格并不需要使用额外的空间，只需要改变方格中存储的值就可以。
 - 加上其他搜索判断以及求值的代码。
