> 矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2)
> 是右上角的坐标。矩形的上下边平行于 x 轴，左右边平行于 y 轴。
> 
> 如果相交的面积为正 ，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。
> 
> 给出两个矩形 rec1 和 rec2 。如果它们重叠，返回 true；否则，返回 false 。

方法一：反向思维
思路：我们尝试分析在什么情况下，矩形 rec1 和 rec2 没有重叠。
矩形 rec1 完全在矩形 rec2 的左侧/右侧/上侧/下侧时；

算法
具体地，我们用 (rec[0], rec[1]) 表示矩形的左下角，(rec[2], rec[3]) 表示矩形的右上角。对于「左侧」，即矩形 rec1 在 x 轴上的最大值不能大于矩形 rec2 在 x 轴上最小值。对于「右侧」、「上方」以及「下方」同理。因此我们可以翻译成如下的代码：

左侧：rec1[2] <= rec2[0]；
右侧：rec1[0] >= rec2[2]；
上方：rec1[1] >= rec2[3]；
下方：rec1[3] <= rec2[1]。

```javascript
var isRectangleOverlap = function(rec1, rec2) {
    //验证不构成矩形的情况
    if(rec1[0] >= rec1[2] || rec1[1] >= rec1[3] ||
    rec2[0] >= rec2[2] || rec2[1] >= rec2[3]){
        return false;
    }
    return !(rec1[2] <= rec2[0] ||
             rec1[1] >= rec2[3] ||
             rec1[0] >= rec2[2] ||
             rec1[3] <= rec2[1]);
};
```
因为在leetcode测试用例中出现了[-1,0,1,1]和[0,-1,0,1]，所以验证了不构成矩形的情况。
但是leetcode题目描述里提示的范围为：

> rec1[0] <= rec1[2] 且 rec1[1] <= rec1[3] 
> rec2[0] <= rec2[2] 且 rec2[1]<= rec2[3]

此处存疑。

方法二：检查区域
思路：如果两个矩形重叠，那么它们重叠的区域一定也是一个矩形，那么这代表了两个矩形与 x轴平行的边（水平边）投影到 x 轴上时会有交集，与 y 轴平行的边（竖直边）投影到 y 轴上时也会有交集。因此，我们可以将问题看作一维线段是否有交集的问题。

算法：矩形 rec1 和 rec2 的水平边投影到 x 轴上的线段分别为 (rec1[0], rec1[2]) 和 (rec2[0], rec2[2])。根据数学知识我们可以知道，当 min(rec1[2], rec2[2]) > max(rec1[0], rec2[0]) 时，这两条线段有交集。对于矩形 rec1 和 rec2 的竖直边投影到 y 轴上的线段，同理可以得到，当 min(rec1[3], rec2[3]) > max(rec1[1], rec2[1]) 时，这两条线段有交集。

```javascript
var isRectangleOverlap = function(rec1, rec2) {
        return (Math.min(rec1[2], rec2[2]) > Math.max(rec1[0], rec2[0]) &&
                Math.min(rec1[3], rec2[3]) > Math.max(rec1[1], rec2[1]));
};
```
两种方法的复杂度一样，均为：
时间复杂度：O(1)O(1)。
空间复杂度：O(1)O(1)，不需要额外的空间。
